class t{static isBoolean(t){return"boolean"==typeof t}static hasValue(t){return 1==t&&1==t}static isTrue(t){return!0===t}static isFalse(t){return!1===t}}class e{static castTo(t,e){return Object.assign(new t,e)}}class r{static from(t,e){let s=new r;for(var i in t){let r=e?e(t[i]):t[i];s.add(e(r))}return s}constructor(t){this.list=null,this.list=void 0!==t&&t instanceof Array?t:[]}get(t){return this.list[t]}set(t,e){return this.list[t]=e,this}getLast(){return this.list.length>0?this.list[this.list.length-1]:null}setLast(t){return this.list.length>0?(this.list[this.list.length-1]=t,this):null}add(t){return this.list.push(t),this}remove(t){return this.list=this.list.filter((function(e){return e!=t})),this}size(){return this.list.length}valueAtEquals(t,e){return null!==this.get(t)&&void 0!==this.get(t)&&this.get(t)===e}contains(t){return this.getArray().includes(t)}firstValueEquals(t){return this.valueAtEquals(0,t)}forEach(t,e){for(let r of this.list)if(!t(r,e))break}promiseChain(t,e){return new Promise(((s,i)=>{r.promiseChainStep(t,this.list,e,0,s,i)}))}static promiseChainStep(t,e,s,i,n,a){i>=e.length?n():t(e[i],s).then((()=>{r.promiseChainStep(t,e,s,i+1,n,a)})).catch((t=>{a(t)}))}addAll(t){return t.forEach((function(t,e){return e.add(t),!0}),this),this}getArray(){return this.list}filter(t){return new r(this.list.filter(t))}}class s{static reverse(t){for(var e=new r,s=t.size()-1;s>=0;s--)e.add(t.get(s));return e}}class i{constructor(t,e){this.object=t,this.function=e}call(t){return Array.isArray(t)?this.function.call(this.object,...t):this.function.call(this.object,t)}}let n=null,a=null;class l{static get FATAL(){return 1}static get ERROR(){return 2}static get WARN(){return 3}static get INFO(){return 4}static get DEBUG(){return 5}static get FATAL_LABEL(){return"FATAL"}static get ERROR_LABEL(){return"ERROR"}static get WARN_LABEL(){return"WARN "}static get INFO_LABEL(){return"INFO "}static get DEBUG_LABEL(){return"DEBUG"}constructor(t){this.logName=t}static set level(t){n=t}static set listener(t){a=t}static clearListener(){a=null}static get level(){return n||l.INFO}info(t,e=0){l.log(t,this.logName,l.INFO,l.INFO_LABEL,(t=>{console.info(t)}),e)}warn(t,e=0){l.log(t,this.logName,l.WARN,l.WARN_LABEL,(t=>{console.warn(t)}),e)}debug(t,e=0){l.log(t,this.logName,l.DEBUG,l.DEBUG_LABEL,(t=>{console.debug(t)}),e)}error(t,e=0){l.log(t,this.logName,l.ERROR,l.ERROR_LABEL,(t=>{console.error(t)}),e)}fatal(t,e=0){l.log(t,this.logName,l.FATAL,l.FATAL_LABEL,(t=>{console.fatal(t)}),e)}static log(t,e,r,s,i,n){if(l.level<r)return;let o=(new Date).toISOString();if("object"==typeof t?(i(s+" "+o+" "+e+":"),i(t)):i(s+" "+o+" "+e+" "+l.indent(n,t)),a){if("object"==typeof t)return void(t instanceof Error?a.call([t.stack,r]):a.call([JSON.stringify(t,null,2),r]));if(void 0===t)return void a.call(["undefined",r]);a.call([t,r])}}static indent(t,e){if(0===t)return e;let r="";r+=t;for(let e=0;e<t;e++)r+=" ";return r+=e,r}showPos(t,e){if(n<l.DEBUG)return;let r="";for(let s=0;s<t.length;s++)r+=s==e?"+":" ";console.log(r),console.log(t),console.log(r)}}class o{constructor(){this.map={}}size(){return Object.keys(this.map).length}get(t){return this.map[t]}set(t,e){return this.map[t]=e,this}remove(t){delete this.map[t]}contains(t){return this.exists(t)}exists(t){return t in this.map}forEach(t,e){for(let r in this.map)if(!t(r,this.map[r],e))break}promiseChain(t,e){let r=[],s=[];for(let t in this.map)r.push(t),s.push(this.map[t]);return new Promise(((i,n)=>{o.promiseChainStep(t,r,s,e,0,i,n)}))}static promiseChainStep(t,e,r,s,i,n,a){i>=r.length?n():t(e[i],r[i],s).then((()=>{o.promiseChainStep(t,e,r,s,i+1,n,a)})).catch((t=>{a(t)}))}addAll(t){t.forEach((function(t,e,r){return r.set(t,e),!0}),this)}}class c{static isNumber(t){return"number"==typeof t}static hasValue(t){return null==t}}const u=new l("ObjectMapper");class h{static map(t,e){return void 0===t&&u.error("No source object"),void 0===e&&u.error("No destination object"),new r(Object.keys(t)).forEach((r=>{if(void 0===e[r])throw u.error("Unable to map "+r+" from"),u.error(t),u.error("to"),u.error(e),"Unable to map object";return e[r]=t[r],!0}),this),e}}class g{static getValue(t,e){for(var r=e.split("."),s=0,i=r.length;s<i;++s){var n=r[s];if(!(n in t))return;t=t[n]}return t}static setValue(t,e,r){for(var s=e.split("."),i=0,n=s.length;i<n;++i){var a=s[i];if(i==n-1)return void(t[a]=r);a in t&&null!==t[a]||(t[a]={}),t=t[a]}}}class f{static isInAlphabet(t){return t.charCodeAt(0)>=65&&t.charCodeAt(0)<=90||(t.charCodeAt(0)>=97&&t.charCodeAt(0)<=122||t.charCodeAt(0)>=48&&t.charCodeAt(0)<=57)}static isString(t){return"string"==typeof t}static isBlank(t){return!f.hasValue(t)||""===t}static hasValue(t){return 1==t&&1==t}static nonNullEquals(t,e){return!!t&&(!!e&&t==e)}static equals(t,e){return t==e}static startsWith(t,e){return!(!t||!e)&&t.startsWith(e)}}class p{static asPromise(t,e){return new Promise(((r,s)=>{setTimeout((()=>{e.call(),r.call()}),t)}))}}export{t as BooleanUtils,e as CastUtils,r as List,s as ListUtils,l as Logger,o as Map,c as NumberUtils,i as ObjectFunction,h as ObjectMapper,g as PropertyAccessor,f as StringUtils,p as TimePromise};
