class t{static isBoolean(t){return"boolean"==typeof t}static hasValue(t){return 1==t&&1==t}static isTrue(t){return!0===t}static isFalse(t){return!1===t}}class r{static castTo(t,r){return Object.assign(new t,r)}}class e{static from(t,r){let s=new e;for(var i in t){let e=r?r(t[i]):t[i];s.add(r(e))}return s}constructor(t){this.list=null,this.list=void 0!==t&&t instanceof Array?t:null!=t?[t]:[]}get(t){return this.list[t]}set(t,r){return this.list[t]=r,this}getLast(){return this.list.length>0?this.list[this.list.length-1]:null}setLast(t){return this.list.length>0?(this.list[this.list.length-1]=t,this):null}add(t){return this.list.push(t),this}remove(t){return this.list=this.list.filter((function(r){return r!=t})),this}size(){return this.list.length}valueAtEquals(t,r){return null!==this.get(t)&&void 0!==this.get(t)&&this.get(t)===r}contains(t){return this.getArray().includes(t)}firstValueEquals(t){return this.valueAtEquals(0,t)}forEach(t,r){for(let e of this.list)if(!t(e,r))break}promiseChain(t,r){return new Promise(((s,i)=>{e.promiseChainStep(t,this.list,r,0,s,i)}))}static async promiseChainStep(t,r,s,i,n,a){if(i>=r.length)return n(),null;try{await t(r[i],s),e.promiseChainStep(t,r,s,i+1,n,a)}catch(t){a(t)}}addAll(t){return t.forEach((function(t,r){return r.add(t),!0}),this),this}getArray(){return this.list}filter(t){return new e(this.list.filter(t))}}class s{static isInAlphabet(t){return t.charCodeAt(0)>=65&&t.charCodeAt(0)<=90||(t.charCodeAt(0)>=97&&t.charCodeAt(0)<=122||t.charCodeAt(0)>=48&&t.charCodeAt(0)<=57)}static isString(t){return"string"==typeof t}static isBlank(t){return!s.hasValue(t)||""===t}static hasValue(t){return null!=t}static nonNullEquals(t,r){return!!t&&(!!r&&t==r)}static equals(t,r){return t==r}static startsWith(t,r){return!(!t||!r)&&t.startsWith(r)}static compressWhitespace(t){if(s.isBlank(t))return t;for(;t.indexOf("  ")>-1;)t=t.replace("  "," ");return t}static toArray(t,r,e=!0,i=!0){return e&&(t=s.trim(t)),i&&(t=s.compressWhitespace(t)),s.isBlank(t)?[]:s.isBlank(r)||-1==t.indexOf(r)?[t]:t.split(r)}static trim(t){return s.isBlank(t)?t:t.trim()}static leftPad(t,r,e){let s=t;for(;s.length<r;)s=e+s;return s}static contains(t,r){return!(!s.hasValue(t)||!s.hasValue(r))&&r.indexOf(t)>-1}}class i{static toString(t,r){let e="";return t.forEach(((t,i)=>{i>0&&!s.isBlank(r)&&(e+=r),t.toString?e+=t.toString():e+=t})),e}static merge(t){if(!t||0===t.length)return null;const r=new Array;return t.forEach((t=>{t.forEach((t=>{r.includes(t)||r.push(t)}))})),r}static add(t,r){if(!t)return null;const e=new Array;return t.forEach((t=>{t!==r&&e.push(t)})),e.push(r),e}static promiseChain(t,r){return new Promise(((e,s)=>{i.promiseChainStep(r,t,0,e,s)}))}static async promiseChainStep(t,r,e,s,n){if(e>=r.length)return s(),null;try{await t(r[e]),i.promiseChainStep(t,r,e+1,s,n)}catch(t){n(t)}}static contains(t,r){if(!r)return!1;for(let e=0;e<r.length;e++)if(r[e]===t)return!0;return!1}}class n{static reverse(t){for(var r=new e,s=t.size()-1;s>=0;s--)r.add(t.get(s));return r}}class a{constructor(t,r=null){if(this.object=r,this.function=t,null===this.function||void 0===this.function||"function"!=typeof this.function)throw console.trace(),new Error("Method function missing")}call(t){const r=this.object?this.object:this;return Array.isArray(t)?this.function.call(r,...t):this.function.call(r,t)}}let l=null,o=null;class c{static get FATAL(){return 1}static get ERROR(){return 2}static get WARN(){return 3}static get INFO(){return 4}static get DEBUG(){return 5}static get FATAL_LABEL(){return"FATAL"}static get ERROR_LABEL(){return"ERROR"}static get WARN_LABEL(){return"WARN "}static get INFO_LABEL(){return"INFO "}static get DEBUG_LABEL(){return"DEBUG"}constructor(t){this.logName=t}static set level(t){l=t}static set listener(t){o=t}static clearListener(){o=null}static get level(){return l||c.INFO}info(t,r=0){c.log(t,this.logName,c.INFO,c.INFO_LABEL,(t=>{console.info(t)}),r)}warn(t,r=0){c.log(t,this.logName,c.WARN,c.WARN_LABEL,(t=>{console.warn(t)}),r)}debug(t,r=0){c.log(t,this.logName,c.DEBUG,c.DEBUG_LABEL,(t=>{console.debug(t)}),r)}error(t,r=0){c.log(t,this.logName,c.ERROR,c.ERROR_LABEL,(t=>{console.error(t)}),r),console.trace()}fatal(t,r=0){c.log(t,this.logName,c.FATAL,c.FATAL_LABEL,(t=>{console.fatal(t)}),r)}static log(t,r,e,s,i,n){if(c.level<e)return;let a=(new Date).toISOString();if("object"==typeof t?(i(s+" "+a+" "+r+":"),i(t)):i(s+" "+a+" "+r+" "+c.indent(n,t)),o){if("object"==typeof t)return void(t instanceof Error?o.call([t.stack,e]):o.call([JSON.stringify(t,null,2),e]));if(void 0===t)return void o.call(["undefined",e]);o.call([t,e])}}static indent(t,r){if(0===t)return r;let e="";e+=t;for(let r=0;r<t;r++)e+=" ";return e+=r,e}showPos(t,r){if(l<c.DEBUG)return;let e="";for(let s=0;s<t.length;s++)e+=s==r?"+":" ";console.log(e),console.log(t),console.log(e)}}class u{static toMacAddress(t){return t.toString(16).toUpperCase().padStart(12,"0").match(/.{1,2}/g).reverse().join(":")}}class h{constructor(){this.map={}}static from(t){const r=new h;return t instanceof h||t.map?r.map=t.map:r.map=t,r}size(){return Object.keys(this.map).length}get(t){return this.map[t]}set(t,r){return this.map[t]=r,this}remove(t){delete this.map[t]}contains(t){return this.exists(t)}exists(t){return t in this.map}forEach(t,r){for(let e in this.map)if(!t(e,this.map[e],r))break}promiseChain(t,r){let e=[],s=[];for(let t in this.map)e.push(t),s.push(this.map[t]);return new Promise(((i,n)=>{h.promiseChainStep(t,e,s,r,0,i,n)}))}static promiseChainStep(t,r,e,s,i,n,a){i>=e.length?n():t(r[i],e[i],s).then((()=>{h.promiseChainStep(t,r,e,s,i+1,n,a)})).catch((t=>{a(t)}))}addAll(t){t.forEach((function(t,r,e){return e.set(t,r),!0}),this)}}class f{static toString(t,r="=",e="&"){let s="",i=!0;return t.forEach(((t,n,a)=>{i||(s+=e),i=!1;let l=t;l.toString&&(l=l.toString());let o=n;return o.toString&&(o=o.toString()),s=s+l+r+o,!0})),s}static merge(t,r=!0){const e=new h;return t&&0!==t.length?(t.forEach((t=>{t.forEach(((t,s)=>{!r&&e.has(s)||e.set(s,t)}))})),e):null}}class g{static isNumber(t){return"number"==typeof t}static hasValue(t){return null==t}}const p=new c("ObjectMapper");class m{static mapAll(t,r){let e=[];return t.forEach((t=>{e.push(this.map(t,new r))})),e}static map(t,r){return void 0===t&&p.error("No source object"),void 0===r&&p.error("No destination object"),new e(Object.keys(t)).forEach((e=>{if(void 0===r[e])throw p.error("Unable to map "+e+" from"),p.error(t),p.error("to"),p.error(r),"Unable to map object";return r[e]=t[e],!0}),this),r}}class d{static getValue(t,r){for(var e=r.split("."),s=0,i=e.length;s<i;++s){var n=e[s];if(!(n in t))return;t=t[n]}return t}static setValue(t,r,e){for(var s=r.split("."),i=0,n=s.length;i<n;++i){var a=s[i];if(i==n-1)return void(t[a]=e);a in t&&null!==t[a]||(t[a]={}),t=t[a]}}}class A{static CUSTOM_CHARACTERS="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";static isValidRadixString(t){if(null==t||0===t.length)return!1;const r=A.CUSTOM_CHARACTERS.split("");for(const e of t.split("")){let t=!1;for(const s of r)if(e===s){t=!0;break}if(!t)return!1}return!0}static toRadixString(t){const r=A.CUSTOM_CHARACTERS.split("");let e="";for(;t>0;){e=r[Math.floor(t%r.length)]+e,t=Math.floor(t/r.length)}return e}static fromRadixString(t){const r=A.CUSTOM_CHARACTERS.split("");let e=0;for(let s=0;s<t.length;s++){const i=t.charAt(s),n=r.indexOf(i);if(-1==n)throw Error("Invalid character in radix string: "+i);e=e*r.length+n}return e}}class E{static from(t){return new E(t)}constructor(t){this.theString=t}set(t,r){return this.theString=this.theString.replace("{"+t+"}",r),this}toString(){return this.theString}}class S{static asPromise(t,r){return new Promise(((e,s)=>{setTimeout((()=>{r.call(),e.call()}),t)}))}}export{i as ArrayUtils,t as BooleanUtils,r as CastUtils,e as List,n as ListUtils,c as Logger,u as MacUtils,h as Map,f as MapUtils,a as Method,g as NumberUtils,m as ObjectMapper,d as PropertyAccessor,A as RadixUtils,E as StringTemplate,s as StringUtils,S as TimePromise};
